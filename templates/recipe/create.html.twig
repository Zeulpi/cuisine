{% extends 'base.html.twig' %}
    
{% block title %}Create Recipe{% endblock %}
    
{% block stylesheets %}
    <pre>  
    <link rel="stylesheet" href="{{ asset('styles/ingredient_popup.css') }}">
    <link rel="stylesheet" href="{{ asset('styles/recipe_create.css') }}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css">
    </pre>
{% endblock %}

{% block body %}
<style>
    .example-wrapper { margin: 1em auto; max-width: 800px; width: 95%; font: 18px/1.5 sans-serif; }
    .example-wrapper code { background: #F5F5F5; padding: 2px 6px; }
</style>

<div class="example-wrapper">
    <h1>Créer une recette</h1>
    
    {{ form_start(form) }}
        <div class="recipe-title">
            <div>
                {{ form_row(form.recipeName) }}
            </div>
            <div>
                {{ form_row(form.recipePortions) }}
            </div>
        </div>
        
        <div class="recipe-ingredients">
            <h3>Ingredients</h3>
            <button id="add-ingredient-button" type="button">Add Ingredient</button>
            <!-- Pop-up pour choisir l'ingrédient -->
            <div id="ingredient-popup" class="popup" style="display: none;">
                <div class="popup-content">
                    <h2>Choose an Ingredient</h2>
                    <p><input type="text" id="ingredient-search" placeholder="Search for an ingredient"></p>
                    <div id="ingredients-list" class="ingredients-list">
                        <div id="ingredients-list" class="ingredients-list">
                            {% for ingredient in ingredients %}
                                <div class="ingredient-card" data-id="{{ ingredient.id }}" data-image="{{ ingredient.image }}" data-name="{{ ingredient.ingredientName }}">
                                    <img src="{{ asset('images/ingredients/' ~ ingredient.image) }}" alt="{{ ingredient.ingredientName }}" style="width: 100px;">
                                    <p>{{ ingredient.ingredientName }}</p>
                                </div>
                            {% else %}
                                <p>No ingredients found.</p>
                            {% endfor %}
                        </div>
                    </div>
                    <div class="pagination-controls">
                        <button id="prev-page" disabled>Previous</button>
                        <span id="current-page-info"></span> <!-- Ajout pour afficher la pagination actuelle -->
                        <button id="next-page">Next</button>
                    </div>
                    <button id="close-popup" type="button">Close</button>
                </div>
            </div>
            <div id="ingredients-container">
                <input type="hidden" id="selected-ingredients" name="selected-ingredients" value="[]">
                <input type="hidden" id="result-ingredients" name="result-ingredients" value="[]">
            </div>
        </div>
        
        
        <div class="recipe-steps">
            <h3>Steps</h3>
            <div id="steps" data-prototype="{{ form_widget(form.recipeSteps.vars.prototype)|e('html_attr') }}">
                {% for step in form.recipeSteps %}
                    <div class="step-item">
                        <!-- Div contenteditable pour l'utilisateur -->
                        <div class="step-frame d-flex flex-row justify-content-between">
                            <div class="step-operation w-50">
                            </div>
                            <div class="step-description w-50" contenteditable="true">
                                {{ step.stepText.vars.value|default('') }}
                            </div>
                        </div>

                        <!-- Champ pour le temps de l'étape -->
                        <div class="step-time">
                            {{ form_widget(step.stepTime) }} <!-- Champ stepTime -->
                        </div>

                        <!-- Champ pour l'unité de temps -->
                        <div class="step-time-unit">
                            {{ form_widget(step.stepTimeUnit) }} <!-- Champ stepTimeUnit -->
                        </div>

                        <!-- Champ pour simultanéité -->
                        <div class="step-simult">
                            {{ form_widget(step.stepSimult) }} <!-- Champ stepSimult -->
                        </div>

                        <button type="button" class="remove-step">Remove</button>

                        <!-- Conteneur pour les opérations de cette étape -->
                        <div class="operations-container">
                            <h4>Operations sur les Ingrédients</h4>
                            <button class="add-operation-button" type="button">Ajouter une opération</button>

                            <!-- Conteneur des opérations ajoutées -->
                            <div class="added-operations">
                                <input type="hidden" class="selected-operations" name="selected-operations" value="[]">
                            </div>
                        </div>
                    </div>
                {% endfor %}
                <input type="hidden" name="all-selected-operations" id="all-selected-operations" value="[]">
                <!-- Pop-up pour choisir une opération -->
                <div class="operation-popup popup" style="display: none;" id="operation-popup">
                    <div class="popup-content">
                        <h5>Ajouter une opération</h5>

                        <!-- Liste des opérations -->
                        <select class="operation-select">
                            <option value="">Choisissez une opération</option>
                            {% for operation in operations %}
                                <option value="{{ operation.id }}">{{ operation.name }}</option>
                            {% endfor %}
                        </select>

                        <!-- Liste des ingrédients -->
                        <select class="ingredient-select">
                            <option value="">Choisissez un ingrédient</option>
                            {% for ingredient in ingredients %}
                                <option value="{{ ingredient.id }}">{{ ingredient.ingredientName }}</option>
                            {% endfor %}
                        </select>

                        <!-- Description du résultat -->
                        <input type="text" class="result-description" placeholder="(ex : Eplucher 5 pommes de terre)">

                        <button class="save-operation-button" type="button">Ajouter</button>
                        <button class="close-operation-popup" type="button">Fermer</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="recipe-image">
            <h3>Image de la recette</h3>
            {{ form_widget(form.image) }}
        </div>
        
        <button type="submit">Save Recipe</button>
    {{ form_end(form) }}

    <a href="{{ path('app_recipe') }}">back to list</a>
</div>

<script type="text/javascript">
document.addEventListener('DOMContentLoaded', () => {
    const addIngredientButton = document.getElementById('add-ingredient-button');
    const ingredientPopup = document.getElementById('ingredient-popup');
    const closePopupButton = document.getElementById('close-popup');
    const ingredientsContainer = document.getElementById('ingredients-container');
    const stepsContainer = document.getElementById('steps');
    const addStepButton = document.createElement('button');
    const addOperationButton = document.getElementById('add-operation-button');
    const operationPopup = document.getElementById('operation-popup');
    const closeOperationPopupButton = document.getElementById('close-operation-popup');
    const saveOperationButton = document.getElementById('save-operation-button');
    const operationsContainer = document.getElementById('operations-container');
    const selectedOperationsField = document.getElementById('selected-operations');
    const ingredientsList = document.getElementById('ingredients-list');
    const prevPageButton = document.getElementById('prev-page');
    const nextPageButton = document.getElementById('next-page');
    const currentPageSpan = document.getElementById('current-page');
    const ingredientSearch = document.getElementById('ingredient-search');
    const currentPageInfo = document.getElementById('current-page-info');
    let activeStepItem = null;
    let tempID = -1;

    addStepButton.textContent = 'Add Step';
    addStepButton.type = 'button';
    stepsContainer.append(addStepButton);

    const ingredients = {{ ingredients|json_encode|raw }}; // Les ingrédients passés depuis Symfony
    const itemsPerPage = {{ingredientsPerPage}}; // Nombre d'ingrédients par page
    let currentPage = 1; // Page actuelle
    const totalPages = Math.ceil(ingredients.length / itemsPerPage); // Nombre total de pages
    let filteredIngredients = [...ingredients]; // Initialement, tous les ingrédients sont visibles

    const operations = {{ operations|json_encode|raw }};

    // Récupérer les ingrédients déjà ajoutés à la recette
    const selectedIngredientsField = document.getElementById('selected-ingredients');
    let selectedIngredients = JSON.parse(selectedIngredientsField.value || '[]');

    // Récupérer les ingrédients intermédiaires
    const resultIngredientsField = document.getElementById('result-ingredients');
    let resultIngredients = JSON.parse(resultIngredientsField.value || '[]');

    let stepIndex = stepsContainer.querySelectorAll('.step-item').length;
    
    // Mettre à jour les options dans la liste des ingrédients du popup opérations
    function updateIngredientOptions(popup) {
        const ingredientSelect = popup.querySelector('.ingredient-select');
        const stepItems = stepsContainer.querySelectorAll('.step-item');
        
        ingredientSelect.innerHTML = '<option value="">Choisissez un ingrédient</option>'; // Réinitialiser

        // Récupérer les ingrédients sélectionnés avec leurs quantités
        const selectedIngredientsField = document.getElementById('selected-ingredients');
        const selectedIngredients = JSON.parse(selectedIngredientsField?.value || '[]');

        //Recupérer les ingrédients intermédiaires
        const resultIngredientsField = document.getElementById('result-ingredients');
        const resultIngredients = JSON.parse(resultIngredientsField?.value || '[]');

        //Ajout des ingrédients de la recette a la selection
        selectedIngredients.forEach(selectedIngredient => {
            const ingredient = ingredients.find(ing => ing.id === parseInt(selectedIngredient.ingredientId));

            if (ingredient) {
                // Ajouter l'ingrédient au menu déroulant
                const option = document.createElement('option');
                option.value = ingredient.id;
                option.textContent = ingredient.ingredientName;
                ingredientSelect.appendChild(option);
            }
        });

        
        // Ajout des operationResult a la selection
        resultIngredients.forEach(resultIngredient => {
            // Ajouter l'ingrédient intermédiaire au menu déroulant
            const option = document.createElement('option');
            option.value = resultIngredient.resultId;
            option.textContent = resultIngredient.resultName;
            ingredientSelect.appendChild(option);
        });
    }

    function sanitizeInput(input) {
        // Créer un élément temporaire pour traiter le HTML
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = input;

        // Supprimer les balises indésirables
        const allowedTags = ['br', 'b', 'i', 'u', 'div', 'span', 'p']; // Ajouter d'autres balises autorisées si nécessaire
        tempDiv.querySelectorAll('*').forEach(node => {
            if (!allowedTags.includes(node.tagName.toLowerCase())) {
                node.replaceWith(document.createTextNode(node.textContent));
            }
        });

        return tempDiv.innerHTML;
    }
    // Fonction pour synchroniser le contenu de "step-description" avec le champ caché
    function syncStepDescription(stepItem, description) {
        const hiddenField = stepItem.querySelector('input[name*="[stepText]"]');
        const sanitizedValue = sanitizeInput(description);
        if (hiddenField) {
            hiddenField.value += sanitizedValue; // Sauvegarder uniquement la description
        }
    }
    // Fonction pour ajouter les ingrédients intermédiaires au champ caché
    function addResultIngredient(resultDescription) {
        const resultIngredientsField = document.getElementById('result-ingredients');
        const resultIngredients = JSON.parse(resultIngredientsField.value || '[]');
        const newResultId = tempID;

        // Ajouter result au tableau des ingrédients intermédiaires
        resultIngredients.push({ resultId: newResultId, resultName: resultDescription }); // Ajout de l'Id négatif
        tempID--; // Décrémentation pour les prochains ID négatifs

        // Mettre à jour le champ caché avec la liste des ingrédients intermédiaires
        resultIngredientsField.value = JSON.stringify(resultIngredients);

        return newResultId;
    }

    // Fonction pour masquer le champ 'stepSimult' pour l'étape 1
    function hideStepSimultForFirstStep() {
        const stepItems = stepsContainer.querySelectorAll('.step-item');
        stepItems.forEach((stepItem, index) => {
            const stepSimult = stepItem.querySelector('input[name*="[stepSimult]"]');
            if (index === 0 && stepSimult) {
                stepSimult.closest('div').style.display = 'none'; // Masque le champ pour l'étape 1
            } else if (stepSimult) {
                stepSimult.closest('div').style.display = ''; // Affiche le champ pour les autres étapes
            }
        });
    }
    
    // Fonction pour supprimer une opération
    function removeOperation(operationItem) {
        if (!operationItem) {
            console.error("Erreur : Aucune opération fournie.");
            return;
        }
        const stepItem = operationItem.closest('.step-item'); // Récupérer l'étape concernée
        const operationsContainer = stepItem.querySelector('.added-operations'); // Conteneur des opérations
        const operationDiv = operationItem.querySelector('.operation');
        const selectedOperationsField = operationsContainer.querySelector('.selected-operations'); // Champ caché

        if (!stepItem || !operationsContainer || !selectedOperationsField) {
            console.error("Erreur : Élément manquant.");
            return;
        }

        // Extraire operationId et ingredientId
        const operationId = parseInt(operationDiv.id.split('_').pop(), 10);
        const ingredientElement = operationItem.querySelector('.ingredient'); 
        const ingredientId = ingredientElement ? parseInt(ingredientElement.id.split('_').pop(), 10) : null;

        if (isNaN(operationId) || isNaN(ingredientId)) {
            console.error("Erreur : ID invalide.");
            return;
        }

        // Récupérer la liste des opérations de l'étape en cours
        let stepOperations = JSON.parse(selectedOperationsField.value || '[]');
        console.log(stepOperations);

        // Trouver le resultId avant suppression
        const resultId = stepOperations.find(op => op.operationId === operationId && op.ingredientId === ingredientId)?.operationResult;
        console.log(resultId);

        // Supprimer visuellement l'opération
        operationItem.remove();

        // Supprimer l'opération du tableau
        stepOperations = stepOperations.filter(op => !(op.operationId === operationId && op.ingredientId === ingredientId));

        // Mettre à jour le champ caché des opérations
        selectedOperationsField.value = stepOperations.length > 0 ? JSON.stringify(stepOperations) : '';

        // Si un résultat intermédiaire est supprimé, supprimer toutes les opérations qui l’utilisent
        if (resultId !== null && resultId < 0) {
            removeDependentOperations(resultId);
        }
        // Mettre à jour la liste des ingrédients intermédiaires
        cleanupResultIngredients();
    }
    // Fonction pour supprimer les opérations dépendantes d'un ingrédient supprimé
    function removeDependentOperations(deletedIngredientId) {
        const stepItems = document.querySelectorAll('.step-item'); // Sélectionner tous les step-items

        stepItems.forEach((stepItem, stepIndex) => {
            const operationsContainer = stepItem.querySelector('.added-operations');
            const selectedOperationsField = operationsContainer.querySelector('.selected-operations');
            let stepOperations = JSON.parse(selectedOperationsField.value || '[]');  // Récupérer les opérations de l'étape

            // Trouver les opérations qui dépendent de l'ingrédient supprimé
            const dependentOperations = stepOperations.filter(op => op.ingredientId === deletedIngredientId);

            dependentOperations.forEach((op) => {
                const operationId = op.operationId;

                // Sélectionner toutes les opérations ayant le même operationId dans cette étape
                const operationElements = stepItem.querySelectorAll(`#operation_${stepIndex + 1}_${operationId}`);
                
                operationElements.forEach((operationElement) => {
                    // Vérifier si l'ingrédient associé à l'opération est le bon
                    const ingredientElement = operationElement.closest('.operation-item').querySelector('.ingredient');
                    const operationIngredientId = ingredientElement ? parseInt(ingredientElement.id.split('_').pop(), 10) : null;

                    // Si l'opération utilise l'ingrédient supprimé, la supprimer
                    if (operationIngredientId === deletedIngredientId) {
                        operationElement.closest('.operation-item').remove();  // Supprimer visuellement l'opération
                        // Appeler removeOperation pour mettre à jour les données et supprimer l'opération
                        removeOperation(operationElement);
                    }
                });
            });

            // Mettre à jour le champ caché avec les opérations restantes
            stepOperations = stepOperations.filter(op => !dependentOperations.includes(op)); // Supprimer les opérations dépendantes
            selectedOperationsField.value = JSON.stringify(stepOperations);  // Mettre à jour le champ caché
        });
    }
    // Fonction pour nettoyer les ingrédients intermédiaires non utilisés
    function cleanupResultIngredients() {
        const resultIngredientsField = document.getElementById('result-ingredients');
        let resultIngredients = JSON.parse(resultIngredientsField.value || '[]');

        // Récupérer tous les `selected-operations` pour voir quels resultIds sont encore utilisés
        const usedResultIds = new Set();
        document.querySelectorAll('.selected-operations').forEach(field => {
            const stepOperations = JSON.parse(field.value || '[]');
            stepOperations.forEach(op => {
                if (op.operationResult && op.operationResult < 0) {
                    usedResultIds.add(op.operationResult);
                }
            });
        });

        // Filtrer pour ne garder que les resultIngredients encore utilisés
        resultIngredients = resultIngredients.filter(result => usedResultIds.has(result.resultId));

        // Mettre à jour le champ caché
        resultIngredientsField.value = JSON.stringify(resultIngredients);
    }

    // Modifier la liste des ingrédients par un champ de recherche
    ingredientSearch.addEventListener('input', (e) => {
        const searchValue = e.target.value.toLowerCase();
        const filteredIngredients = ingredients.filter(ingredient => ingredient.ingredientName.toLowerCase().includes(searchValue));
        displayPage(1, filteredIngredients);
    });

    // Fonction pour afficher une page d'ingrédients dans le popup
    function displayPage(page, ingredientSubset) {
        const startIndex = (page - 1) * itemsPerPage;
        const endIndex = startIndex + itemsPerPage;

        // Sous-ensemble des ingrédients à afficher
        const ingredientsToDisplay = ingredientSubset.slice(startIndex, endIndex);

        // Mise à jour du conteneur d'ingrédients
        ingredientsList.innerHTML = ingredientsToDisplay
            .map(
                ingredient => `
                <div class="ingredient-card" data-id="${ingredient.id}" data-name="${ingredient.ingredientName}" data-image="${ingredient.image}">
                    <img src="/images/ingredients/${ingredient.image}" alt="${ingredient.ingredientName}" style="width: 100px;">
                    <p>${ingredient.ingredientName}</p>
                </div>
            `
            )
            .join('');

        // Mise à jour de l'information de pagination
        const totalPages = Math.ceil(ingredientSubset.length / itemsPerPage);
        currentPageInfo.textContent = `Page ${page} / ${totalPages}`;
        currentPage = page;

        // Gestion des boutons de navigation
        updatePaginationButtons(totalPages);
        disableSelectedIngredients();
    }

    // Fonction pour mettre à jour les boutons "Précédent" et "Suivant" dans le popup ingrédients
    function updatePaginationButtons(totalPages) {
        const prevButton = document.getElementById('prev-page');
        const nextButton = document.getElementById('next-page');

        prevButton.disabled = currentPage <= 1;
        nextButton.disabled = currentPage >= totalPages;

        prevButton.onclick = () => {
            if (currentPage > 1) {
                displayPage(currentPage - 1, filteredIngredients);
            }
        };

        nextButton.onclick = () => {
            if (currentPage < totalPages) {
                displayPage(currentPage + 1, filteredIngredients);
            }
        };
    }
    // Gérer la recherche d'ingrédients dans le popup ingrédients
    ingredientSearch.addEventListener('input', (e) => {
        const searchValue = e.target.value.toLowerCase();
        filteredIngredients = ingredients.filter(ingredient =>
            ingredient.ingredientName.toLowerCase().includes(searchValue)
        );

        // Réinitialiser à la première page des résultats filtrés
        displayPage(1, filteredIngredients);
    });

    // Ouvrir le popup ingrédients
    addIngredientButton.addEventListener('click', function() {
        ingredientPopup.style.display = 'block';
        // displayPage(1, filteredIngredients);
    });

    // Fermer le popup ingrédients
    closePopupButton.addEventListener('click', function () {
        ingredientPopup.style.display = 'none';
    });
    // Initialisation
    displayPage(1, filteredIngredients);

    // Désactiver les ingrédients déjà ajoutés
    function disableSelectedIngredients() {
        const ingredientCards = document.querySelectorAll('.ingredient-card');
        ingredientCards.forEach(card => {
            const ingredientId = card.getAttribute('data-id');
            if (selectedIngredients.some(item => item.ingredientId == ingredientId)) { // Comparaison avec ingredientId
                card.classList.add('disabled'); // Ajouter une classe 'disabled'
                const button = card.querySelector('button'); 
                if (button) {
                    button.disabled = true; // Désactiver le bouton
                }
            } else {
                card.classList.remove('disabled'); // Retirer la classe 'disabled'
                const button = card.querySelector('button'); 
                if (button) {
                    button.disabled = false; // Activer le bouton
                }
            }
        });
    }

    // Sélectionner un ingrédient
    document.getElementById('ingredients-list').addEventListener('click', (e) => {
        if (e.target && e.target.closest('.ingredient-card')) {
            const selectedCard = e.target.closest('.ingredient-card');
            const ingredientId = parseInt(selectedCard.getAttribute('data-id'), 10);
            const ingredientImage = selectedCard.getAttribute('data-image');
            const ingredientName = selectedCard.getAttribute('data-name');

            // Ajouter l'ingrédient sélectionné à la recette
            const ingredientDiv = document.createElement('div');
            ingredientDiv.classList.add('ingredient-item');
            ingredientDiv.setAttribute('data-id', ingredientId); 

            ingredientDiv.innerHTML = `
                <img src="/images/ingredients/${ingredientImage}" alt="${ingredientName}" style="width: 50px;">
                <span>${ingredientName}</span>
                <input type="number" class="ingredient-quantity" placeholder="Quantity" min="0" step="0.1" value="1">
                <input type="text" class="ingredient-unit" placeholder="Unit (e.g. kg)" value=""/>
                <button type="button" class="remove-ingredient">Remove</button>
            `;
            ingredientsContainer.appendChild(ingredientDiv);

            // Ajouter l'ID au tableau des ingrédients sélectionnés
            selectedIngredients.push({ ingredientId, quantity: 1 }); // Valeur par défaut pour la quantité

            // Mettre à jour le champ caché avec la liste des ingrédients sélectionnés
            selectedIngredientsField.value = JSON.stringify(selectedIngredients);

            // Désactiver les ingrédients déjà sélectionnés
            disableSelectedIngredients(); 

            // Fermer le pop-up après sélection
            ingredientPopup.style.display = 'none';
        }
    });

    // Mise à jour des quantités par ingrédient
    ingredientsContainer.addEventListener('input', (e) => {
        const ingredientDiv = e.target.closest('.ingredient-item');
        const ingredientId = parseInt(ingredientDiv.getAttribute('data-id')); // Convertir en entier
        const quantityInput = ingredientDiv.querySelector('.ingredient-quantity');
        const quantity = parseFloat(quantityInput.value); // Convertir en float
        const unitInput = ingredientDiv.querySelector('.ingredient-unit');
        const unit = unitInput.value.trim(); // Récupérer l'unité saisie

        // Si l'élément modifié est la quantité
        if (e.target && e.target.classList.contains('ingredient-quantity')) {

            if (isNaN(quantity) || quantity <= 0) {
                alert('Please enter a valid quantity.');
                e.target.value = 1; // Valeur par défaut si la quantité n'est pas valide
                return;
            }

            // Mettre à jour la quantité dans `selectedIngredients`
            const selectedIngredientsField = document.getElementById('selected-ingredients');
            let selectedIngredients = JSON.parse(selectedIngredientsField.value || '[]');

            // Trouver l'ingrédient et mettre à jour sa quantité
            const ingredientIndex = selectedIngredients.findIndex(ing => parseInt(ing.ingredientId, 10) === parseInt(ingredientId, 10)); // Conversion explicite

            if (ingredientIndex !== -1) {
                selectedIngredients[ingredientIndex].quantity = quantity;
                selectedIngredients[ingredientIndex].unit = unit; // Ajouter l'unité
                selectedIngredientsField.value = JSON.stringify(selectedIngredients); // Mise à jour du champ caché
            }
        }
        // Si l'élément modifié est l'unité
        if (e.target && e.target.classList.contains('ingredient-unit')) {

            // Mettre à jour l'unité dans `selectedIngredients`
            const selectedIngredientsField = document.getElementById('selected-ingredients');
            let selectedIngredients = JSON.parse(selectedIngredientsField.value || '[]');

            // Trouver l'ingrédient et mettre à jour son unité
            const ingredientIndex = selectedIngredients.findIndex(ing => parseInt(ing.ingredientId, 10) === ingredientId); // Conversion explicite
            if (ingredientIndex !== -1) {
                selectedIngredients[ingredientIndex].quantity = quantity;
                selectedIngredients[ingredientIndex].unit = unit; // Mettre à jour l'unité
                selectedIngredientsField.value = JSON.stringify(selectedIngredients); // Mise à jour du champ caché
            }
        }
    });

    // Gestion de la suppression des ingrédients
    ingredientsContainer.addEventListener('click', (e) => {
        if (e.target && e.target.classList.contains('remove-ingredient')) {
            const ingredientDiv = e.target.closest('.ingredient-item');
            const ingredientId = parseInt(ingredientDiv.getAttribute('data-id')); // Récupérer l'ID de l'ingrédient

            // Supprimer l'élément visuel
            ingredientDiv.remove();

            // Mettre à jour le champ caché
            selectedIngredients = selectedIngredients.filter(ing => ing.ingredientId !== ingredientId);
            selectedIngredientsField.value = JSON.stringify(selectedIngredients);

            // Supprimer les opérations contenant cet ingrédient
            document.querySelectorAll('.operation-item').forEach(operationItem => {
                const ingredientElement = operationItem.querySelector('.ingredient');
                
                if (ingredientElement) {
                    const extractedId = parseInt(ingredientElement.id.split('_').pop(), 10); // Récupérer l'ingredientId
                    if (extractedId === ingredientId) {
                        removeOperation(operationItem); // Utiliser la fonction existante pour supprimer l'opération
                    }
                }
            });
            // Réactiver les ingrédients disponibles
            disableSelectedIngredients();
        }
    });

    // Appeler la fonction au chargement de la page pour masquer 'stepSimult' pour la première étape
    hideStepSimultForFirstStep();
    
    // Ajouter une étape
    addStepButton.addEventListener('click', (e) => {
        e.preventDefault();

        const prototype = stepsContainer.dataset.prototype;
        const newForm = prototype.replace(/__name__/g, stepIndex);

        const newStepElement = document.createElement('div');
        newStepElement.classList.add('step-item');

        // Création de la structure HTML de la nouvelle étape avec un div contenteditable
        newStepElement.innerHTML = `
            ${newForm}
            <div><span>Ajoutez ici la description de l'étape. (ou ajoutez des operations sur les ingrédients)</p></div>
            <div class="step-frame d-flex flex-row justify-content-between">
                <div class="step-operation w-50"></div>
                <div class="step-description w-50" contenteditable="true" id="step-description-${stepIndex}"></div>
            </div>
            <button type="button" class="remove-step">Remove</button>
            <div class="operations-container">
                <h4>Opérations sur les Ingrédients</h4>
                <button class="add-operation-button" type="button">Ajouter une opération</button>
                <div class="added-operations">
                    <input type="hidden" class="selected-operations" name="selected-operations" value="[]">
                </div>
            </div>
        `;

        stepsContainer.appendChild(newStepElement);
        stepIndex++;

        hideStepSimultForFirstStep();
    });

    // Supprimer une étape
    stepsContainer.addEventListener('click', (e) => {
        if (e.target && e.target.classList.contains('remove-step')) {
            e.target.closest('.step-item').remove();

            // Après suppression, réappliquer la logique pour vérifier les étapes restantes
            hideStepSimultForFirstStep();
        }
    });

    // Gérer les opérations sur les ingrédients
    stepsContainer.addEventListener('click', (e) => {

        // Ouvrir le popup d'opération
        if (e.target && e.target.classList.contains('add-operation-button')) {
            activeStepItem = e.target.closest('.step-item');
            // Réinitialiser les champs du popup à chaque ouverture
            operationPopup.querySelector('.operation-select').value = ''; // Réinitialiser le champ opération
            operationPopup.querySelector('.ingredient-select').value = ''; // Réinitialiser le champ ingrédient
            operationPopup.querySelector('.result-description').value = ''; // Réinitialiser la description
            updateIngredientOptions(operationPopup);
            operationPopup.style.display = 'block';
        }

        // Fermer le popup d'opération
        if (e.target && e.target.classList.contains('close-operation-popup')) {
            operationPopup.style.display = 'none';
        }

        // Sauvegarder une opération dans la description et le champ caché
        if (e.target && e.target.classList.contains('save-operation-button')) {
            const operationSelect = operationPopup.querySelector('.operation-select');
            const ingredientSelect = operationPopup.querySelector('.ingredient-select');
            const descriptionSelect = operationPopup.querySelector('.result-description');
            const stepOp = activeStepItem.querySelector('.step-frame .step-operation');
            const operationsContainer = activeStepItem.querySelector('.added-operations');

            const operationId = operationSelect.value;
            const operationName = operationSelect.options[operationSelect.selectedIndex]?.text;
            const ingredientId = ingredientSelect.value;
            const ingredientName = ingredientSelect.options[ingredientSelect.selectedIndex]?.text;
            const resultDescription = descriptionSelect.value;
            const selectedOperationsField = operationsContainer.querySelector('.selected-operations');
            let newResultId = null;

            // Vérification des champs requis
            if (operationId && ingredientId) {
                // Identifier l'étape par son index dans le conteneur
                const stepIndex = [...stepsContainer.querySelectorAll('.step-item')].indexOf(activeStepItem) +1;
                let stepOperations = JSON.parse(selectedOperationsField.value || '[]');

                // Ajouter visuellement l'opération à la description de l'étape
                stepOp.innerHTML += `
                    <div class="operation-item d-flex flex-row gx-3" id="operation-item_${stepIndex}_${stepOperations.length ?? 0}">
                        <div class="m-2">
                            <button type="button" class="remove-operation btn btn-danger">x</button>
                        </div>
                        <div>
                            <strong class="operation" id="operation_${stepIndex}_${operationId}">${operationName}</strong> 
                            <strong>-</strong> 
                            <strong class="ingredient" id="ingredient_${stepIndex}_${ingredientId}">${ingredientName}</strong>
                            <br>
                            ---> ${resultDescription}
                        </div>
                    </div>
                `;

                // Synchroniser les données avec le champ caché des operations
                stepOperations = JSON.parse(selectedOperationsField.value || '[]');
                
                if (resultDescription.trim() !== ""){
                    newResultId = addResultIngredient(resultDescription);
                }
                
                // Ajouter une nouvelle opération liée à l'étape
                stepOperations.push({
                    stepIndex: stepIndex,
                    operationId: parseInt(operationId),
                    ingredientId: parseInt(ingredientId),
                    operationResult: newResultId !== null ? newResultId : null, // Stocker l'ID du résultat, ou null si aucun
                });

                selectedOperationsField.value = JSON.stringify(stepOperations);

                // Fermer le popup après sauvegarde
                operationPopup.style.display = 'none';
            } else {
                alert('Veuillez remplir tous les champs pour l\'opération.');
            }
        }

        // Supprimer une opération
        if (e.target && e.target.classList.contains('remove-operation')) {
            const operationItem = e.target.closest('.operation-item');
            removeOperation(operationItem);
        }
    });
    
    // Surveillance des keypress dans le champ description
    stepsContainer.addEventListener('keydown', (e) => {
        const stepItem = e.target.closest('.step-item');
        //Ajout d'une description par l'utilisateur
        if(e.target && e.target.classList.contains('step-description') ){
            if (/^[a-z0-9.,;:!?()"'%+\-]$/i.test(e.key) || ['Enter', 'Backspace', ' ', 'Home', 'End', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Control', 'Shift', 'Delete'].includes(e.key)) {
                return;
            }
            else if(e.ctrlKey && e.key === 'b'){
                e.preventDefault();
                document.execCommand('bold');
                return;
            }
            else if(e.ctrlKey && e.key === 'u'){
                e.preventDefault();
                document.execCommand('underline');
                return;
            }
            else if(e.ctrlKey && e.key === 'i'){
                e.preventDefault();
                document.execCommand('italic');
                return;
            }
            else {
                e.preventDefault();
            }
        }
    });
    // Surveillance des copy/paste dans le champ description
    stepsContainer.addEventListener('paste', (e) => {
        const stepItem = e.target.closest('.step-item');
        //Ajout d'une description par l'utilisateur
        if(e.target && e.target.classList.contains('step-description') ){
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text/plain');
            const sanitizedValue = sanitizeInput(text);
            e.target.insertAdjacentText('beforeend', sanitizedValue);
        }
    });

    // Synchroniser les contenus au moment de la soumission
    document.querySelector('form[name="recipe"]').addEventListener('submit', (e) => {
        e.preventDefault();
        
        const stepItems = stepsContainer.querySelectorAll('.step-item');
        const allSelectedOperations = [];

        // Vérifier que des ingrédients ont été sélectionnés
        const selectedIngredientsField = document.getElementById('selected-ingredients');
        const selectedIngredients = JSON.parse(selectedIngredientsField.value || '[]');
        if (selectedIngredients.length === 0) {
            alert('Veuillez sélectionner au moins un ingrédient avant de soumettre.');
            e.preventDefault(); // Empêche l'envoi du formulaire
            return;
        }

        // Mettre à jour les quantités et les unités des ingrédients avant la soumission
        const ingredientItems = ingredientsContainer.querySelectorAll('.ingredient-item');
        
        ingredientItems.forEach((ingredientItem) => {
            const ingredientId = ingredientItem.getAttribute('data-id');
            const quantityInput = ingredientItem.querySelector('.ingredient-quantity');
            const unitInput = ingredientItem.querySelector('.ingredient-unit');
            
            const quantity = parseFloat(quantityInput.value);
            const unit = unitInput.value.trim(); // Récupérer l'unité saisie (peut être vide)

            // Vérifier si la quantité est valide
            if (isNaN(quantity) || quantity <= 0) {
                alert('Veuillez entrer une quantité valide pour chaque ingrédient.');
                e.preventDefault(); // Empêche l'envoi du formulaire
                return;
            }

            // Mettre à jour la quantité et l'unité dans `selectedIngredients`
            const ingredientIndex = selectedIngredients.findIndex(ing => parseInt(ing.ingredientId, 10) === parseInt(ingredientId, 10)); // Conversion explicite
            if (ingredientIndex !== -1) {
                selectedIngredients[ingredientIndex].quantity = quantity;
                selectedIngredients[ingredientIndex].unit = unit; // Ajouter l'unité
            }
        });

        // Mettre à jour le champ caché avec les quantités et unités modifiées
        selectedIngredientsField.value = JSON.stringify(selectedIngredients);

        // Parcourir les étapes et synchroniser les opérations
        stepItems.forEach((stepItem, index) => {
            //Synchroniser les descriptions des étapes
            const stepDescription = stepItem.querySelector('.step-description');
            syncStepDescription(stepItem, stepDescription.innerHTML);
            
            // Vérifier les opérations associées à chaque étape
            const operationsContainer = stepItem.querySelector('.added-operations');
            const selectedOperationsField = operationsContainer.querySelector('.selected-operations');
            const stepOperations = JSON.parse(selectedOperationsField.value || '[]');

            // Vérifier qu'il y a bien des opérations associées, sinon un message d'avertissement
            if (stepOperations.length === 0) {
                console.warn(`Aucune opération associée à l'étape ${index + 1} (index ${index}).`);
            }

            // Ajouter le stepIndex à toutes les opérations pour la soumission
            stepOperations.forEach((operation) => {
                if (!operation.stepIndex) {
                    operation.stepIndex = index; // Utilise l'index de l'étape
                }
            });

            // Ajouter les opérations de cette étape au tableau global
            allSelectedOperations.push(...stepOperations);

            // Mettre à jour le champ caché avec les opérations modifiées
            selectedOperationsField.value = JSON.stringify(stepOperations); // Sérialisation
        });

        // Mettre à jour le champ caché global avec toutes les opérations
        const allSelectedOperationsField = document.getElementById('all-selected-operations');
        allSelectedOperationsField.value = JSON.stringify(allSelectedOperations);

        // Vérifier si le formulaire est valide avant soumettre (ajoute d'autres validations si nécessaire)
        if (allSelectedOperations.length === 0) {
            alert('Veuillez ajouter des opérations avant de soumettre.');
            e.preventDefault(); // Empêche l'envoi du formulaire
        }
    });

});
</script>
{% endblock %}
